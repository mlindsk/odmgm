# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Depth First Search
#'
#' Finds the elements in the component of \code{root}
#' 
#' @param adj A named adjacency list of a decomposable grah
#' @param root The node from which the component should be found
#' @return All nodes connected to \code{root}
#' @examples
#' x <- list(a = c("b", "d"), b = c("a", "d"), c = c("b", "a"),
#'           d = c("e", "f"), e = c("d", "f"), f = c("d", "e"))
#' dfs(x, "a")
#' @export
dfs <- function(adj, root) {
    .Call('_odmgm_dfs', PACKAGE = 'odmgm', adj, root)
}

count_unique <- function(x) {
    .Call('_odmgm_count_unique', PACKAGE = 'odmgm', x)
}

matpr <- function(A) {
    .Call('_odmgm_matpr', PACKAGE = 'odmgm', A)
}

n_a <- function(A) {
    .Call('_odmgm_n_a', PACKAGE = 'odmgm', A)
}

na_ya <- function(na, ya) {
    .Call('_odmgm_na_ya', PACKAGE = 'odmgm', na, ya)
}

n_b <- function(na, b) {
    .Call('_odmgm_n_b', PACKAGE = 'odmgm', na, b)
}

subtract_one <- function(x) {
    .Call('_odmgm_subtract_one', PACKAGE = 'odmgm', x)
}

Gx_ <- function(x) {
    .Call('_odmgm_Gx_', PACKAGE = 'odmgm', x)
}

Hx_ <- function(x) {
    .Call('_odmgm_Hx_', PACKAGE = 'odmgm', x)
}

subM <- function(A, x) {
    .Call('_odmgm_subM', PACKAGE = 'odmgm', A, x)
}

a_marginals <- function(A, am) {
    .Call('_odmgm_a_marginals', PACKAGE = 'odmgm', A, am)
}

TY <- function(y, C_marginals, S_marginals) {
    .Call('_odmgm_TY', PACKAGE = 'odmgm', y, C_marginals, S_marginals)
}

#' Maximum Cardinality Search
#' 
#' @param adj A named adjacency list of a decomposable graph
#' @param check Boolean: check if adj is decomposable
#' @details If adj is not the adjacency list of a decomposable graph an error is raised
#' @return A list with a perfect numbering of the nodes and a perfect sequence of sets
#' @examples
#' x <- list(a = c("b", "d"), b = c("a", "c", "d"), c = c("b", "d"), d = c("a", "c", "b"))
#' mcs(x)
#' @export
mcs <- function(adj, check = TRUE) {
    .Call('_odmgm_mcs', PACKAGE = 'odmgm', adj, check)
}

perfect_cliques <- function(x) {
    .Call('_odmgm_perfect_cliques', PACKAGE = 'odmgm', x)
}

perfect_separators <- function(x) {
    .Call('_odmgm_perfect_separators', PACKAGE = 'odmgm', x)
}

parents <- function(po, ps) {
    .Call('_odmgm_parents', PACKAGE = 'odmgm', po, ps)
}

#' Running Intersection Property
#' @description Given a decomposable graph, this functions finds a perfect numbering on the vertices using maximum cardinality search, and hereafter returns a list with two elements: "C" - the cliques and "S" - the separators.
#'
#' @param adj A named adjacency list of a decomposable graph
#' @param check Boolean: check if adj is decomposable
#' @seealso \code{\link{mcs}}, \code{\link{is_decomposable}}
#' @description Given a decomposable graph, this functions finds a perfect numbering on the vertices
#' using maximum cardinality search, and hereafter returns a list with three elements:
#' "C"   - the cliques,
#' "S"   - the separators and
#' "PA" - the parents (all vertices adjacent to the node i that are numbered before node i)
#' @examples
#' x <- list(a = c("b", "d"), b = c("a", "c", "d"), c = c("b", "d"), d = c("a", "c", "b"))
#' y <- rip(x)
#' # Cliques:
#' y$C
#' # Separators:
#' y$S
#' # Parents:
#' y$PA
#' @export
rip <- function(adj, check = TRUE) {
    .Call('_odmgm_rip', PACKAGE = 'odmgm', adj, check)
}

#' Maximum Cardinality Search in Marked Graphs
#' 
#' @param adj A named adjacency list of a decomposable marked graph
#' @param disc_vars Character vector of discrete variables
#' @param check Boolean: check if adj is decomposable
#' @details If adj is not the adjacency list of a decomposable marked graph an error is raised
#' @return A list with a perfect numbering of the nodes and a perfect sequence of sets
#' @examples
#' x <- list(a = c("b", "d"), b = c("a", "c", "d"), c = c("b", "d"), d = c("a", "c", "b"))
#' mcs_marked(x, c("a"))
#' @export
mcs_marked <- function(adj, disc_vars, check = TRUE) {
    .Call('_odmgm_mcs_marked', PACKAGE = 'odmgm', adj, disc_vars, check)
}

#' Running Intersection Property for Marked Graphs
#' @description Given a decomposable marked graph, this functions finds a perfect numbering on the vertices
#' using maximum cardinality search, and hereafter returns a list with three elements:
#' "C"   - the cliques,
#' "S"   - the separators and
#' "PA" - the parents (all vertices adjacent to the node i that are numbered before node i)
#'
#' @param adj A named adjacency list of a decomposable marked graph
#' @param disc_vars Character vector of discrete variables in adj
#' @param check Boolean: check if adj is decomposable
#' @seealso \code{\link{mcs_marked}}, \code{\link{is_decomposable}} 
#' @examples
#' x <- list(a = c("b", "d"), b = c("a", "c", "d"), c = c("b", "d"), d = c("a", "c", "b"))
#' y <- rip_marked(x, c("a"))
#' # Cliques:
#' y$C
#' # Separators:
#' y$S
#' # Parents:
#' y$PA
#' @export
rip_marked <- function(adj, disc_vars, check = TRUE) {
    .Call('_odmgm_rip_marked', PACKAGE = 'odmgm', adj, disc_vars, check)
}

set_intersect <- function(v1, v2) {
    .Call('_odmgm_set_intersect', PACKAGE = 'odmgm', v1, v2)
}

set_union <- function(v1, v2) {
    .Call('_odmgm_set_union', PACKAGE = 'odmgm', v1, v2)
}

set_diff <- function(v1, v2) {
    .Call('_odmgm_set_diff', PACKAGE = 'odmgm', v1, v2)
}

set_eq <- function(v1, v2) {
    .Call('_odmgm_set_eq', PACKAGE = 'odmgm', v1, v2)
}

set_in <- function(a, b) {
    .Call('_odmgm_set_in', PACKAGE = 'odmgm', a, b)
}

set_issubeq <- function(a, b) {
    .Call('_odmgm_set_issubeq', PACKAGE = 'odmgm', a, b)
}

set_any <- function(v) {
    .Call('_odmgm_set_any', PACKAGE = 'odmgm', v)
}

