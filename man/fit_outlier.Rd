% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api_fit_outlier.R
\name{fit_outlier}
\alias{fit_outlier}
\title{Fit Outlier}
\usage{
fit_outlier(
  A,
  z,
  adj,
  alpha = 0.05,
  nsim = 10000,
  ncores = 1,
  validate = TRUE,
  hom = FALSE
)
}
\arguments{
\item{A}{Data without the new observation \code{z} appended (data.frame)}

\item{z}{New observation with same colnames as A (data.frame)}

\item{adj}{Adjacency list or gengraph object of a decomposable graph
without the observation of interest. See details}

\item{alpha}{The significance level}

\item{nsim}{Number of simulations}

\item{ncores}{Number of cores to use in parallelization}

\item{validate}{Logical. If true, it checks if \code{A} has only single character values and converts it if not.}

\item{hom}{Logical indicating whether the model is homogeneous or not if \code{A} has mixed variables}
}
\description{
Outlier test in decomposable graphical models
}
\details{
It is very important to note, that it is assumed that \code{z} is
not appended to \code{A}. It may be, that \code{z} actually belongs to \code{A} and we want
to test if it is an outlier. But then one should pass the subdata \code{A[-zi, ]} where
\code{zi} is the row index of \code{z} in \code{A}. The reason for this is, that under the
null hypothesis, \code{z} is believed to stem from \code{A} and so in the procedure
\code{z} is appended. But if \code{z} is already in \code{A} this may lead to a slightly
different result since \code{z} was in reality appended twice.

The \code{adj} object is most typically found using \code{fit_graph}. But the user can supply
an adjacency list, just a named \code{list}, of their own choice if needed.
}
